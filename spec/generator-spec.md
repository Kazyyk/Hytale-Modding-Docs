# Hytale Server API Index — Engineering Spec

> **Version:** 1.0.0
> **Status:** Complete — all four phases implemented
> **Purpose:** Define the pipeline, output schema, and exploration strategy for
> mechanically generating searchable, human-readable documentation from the
> Hytale server JAR. The generated output serves two consumers: a static
> documentation site (Cloudflare Pages) and a RAG corpus (Cloudflare AI Search via
> MCP).

---

## 1. Design Principles

1. **Single source of truth.** All documentation is derived from the server JAR.
   No community docs, wiki content, or hand-written tutorials are ingested into
   the generated corpus. If the generated docs are wrong, the fix is in the
   generator — not in a separate corrections layer.

2. **Schema-first.** The output format is defined before the generator is built.
   Every downstream consumer (static site, RAG, future tooling) depends on a
   stable, predictable structure.

3. **Phased pipeline.** Each stage produces artifacts that the next stage
   consumes. Failures are isolated and debuggable per-phase.

4. **API surface separation.** Plugin-facing API is clearly separated from
   internal implementation. Both are documented, but with different visibility
   and priority.

5. **Deterministic where possible.** Phases that can be done with static
   analysis are done with static analysis. The LLM is reserved for
   classification, cross-referencing, and prose generation where judgment is
   required.

---

## 2. Pipeline Overview

```
┌─────────────┐     ┌──────────────┐     ┌─────────────────┐     ┌───────────────┐
│  Phase 1     │     │  Phase 2     │     │  Phase 3        │     │  Phase 4      │
│  Decompile   │────▶│  Classify    │────▶│  Map Systems    │────▶│  Generate     │
│  & Index     │     │  API Surface │     │  & Cross-Ref    │     │  Docs         │
└─────────────┘     └──────────────┘     └─────────────────┘     └───────────────┘
     │                    │                      │                       │
     ▼                    ▼                      ▼                       ▼
  artifacts/           artifacts/             artifacts/             output/
  decompiled/          surface.json           systems.json          docs/
  class-index.json     internal-index.json    cross-refs.json       (markdown)
```

### Phase 1 — Decompile & Index

**Goal:** Produce the raw decompiled source tree and a structured index of every
class, method, field, and annotation.

**Tooling:** Vineflower (modern Fernflower fork). Hytale requires Java 25, so
the decompiler must handle recent language features (records, sealed classes,
pattern matching, etc.).

**Inputs:**
- `HytaleServer.jar` (manually placed in a known path)

**Outputs:**
- `artifacts/decompiled/` — Full decompiled source tree.
- `artifacts/class-index.json` — Structured index (see schema below).

**LLM involvement:** None. This phase is fully deterministic.

#### class-index.json Schema

```json
{
  "version": "1.0.0",
  "jar_hash": "sha256:...",
  "generated_at": "2026-02-09T00:00:00Z",
  "classes": [
    {
      "fqcn": "com.hypixel.hytale.plugin.JavaPlugin",
      "package": "com.hypixel.hytale.plugin",
      "name": "JavaPlugin",
      "kind": "class | interface | enum | record | annotation",
      "modifiers": ["public", "abstract"],
      "superclass": "java.lang.Object",
      "interfaces": ["com.hypixel.hytale.plugin.Plugin"],
      "type_parameters": [],
      "annotations": [],
      "fields": [
        {
          "name": "logger",
          "type": "org.slf4j.Logger",
          "modifiers": ["private", "final"],
          "annotations": []
        }
      ],
      "methods": [
        {
          "name": "onEnable",
          "return_type": "void",
          "parameters": [],
          "modifiers": ["public"],
          "annotations": ["java.lang.Override"],
          "throws": []
        }
      ],
      "inner_classes": [],
      "source_file": "artifacts/decompiled/com/hypixel/hytale/plugin/JavaPlugin.java"
    }
  ]
}
```

**Implementation notes:**
- The index should be generated by parsing the decompiled source with a Java
  parser (e.g., JavaParser library via a small Java or Kotlin CLI tool), not by
  regex or LLM extraction. Accuracy here is non-negotiable.
- Store the JAR's SHA-256 hash to enable change detection for future runs.

---

### Phase 2 — Classify API Surface

**Goal:** Separate the plugin-facing API from internal implementation. Produce a
curated list of types that plugin developers interact with, and a separate index
of internal types for advanced reference.

**Strategy — seed and expand:**

1. **Seed types** (known entry points):
   - `com.hypixel.hytale.plugin.JavaPlugin`
   - `com.hypixel.hytale.plugin.JavaPluginInit`
   - `com.hypixel.hytale.server.core.command.system.AbstractCommand`
   - `com.hypixel.hytale.server.core.command.system.CommandContext`
   - `com.hypixel.hytale.server.core.command.system.CommandManager`
   - `com.hypixel.hytale.server.core.Message`
   - Any class/interface in packages matching `*.plugin.*`, `*.api.*`, `*.event.*`

2. **Expansion rules** (transitive closure):
   - For every seed type, add all types referenced in its public/protected
     method signatures (parameter types, return types, generic bounds).
   - Add all types it extends or implements.
   - Add all types used in its public field declarations.
   - Add all annotation types it uses.
   - Recurse until no new types are added.

3. **Exclusion heuristics:**
   - Types in `java.*`, `javax.*`, `org.slf4j.*`, and other standard library
     packages are referenced but not documented (they have their own docs).
   - Types that are only reachable through private/package-private members are
     classified as internal.

**Outputs:**
- `artifacts/surface.json` — List of FQCNs classified as plugin API, with the
  seed or expansion path that included them.
- `artifacts/internal-index.json` — Everything else, tagged as internal.

**LLM involvement:** Minimal. The expansion is mechanical, but the LLM may be
used to review borderline cases — e.g., a type that's technically reachable but
appears to be an implementation detail based on naming conventions or package
structure. These should be flagged for human review rather than silently
reclassified.

---

### Phase 3 — Map Systems & Cross-Reference

**Goal:** Identify the major game systems (events, ECS, commands, registries,
JSON schemas) and build a cross-reference graph.

**This phase is where the LLM does heavy lifting.** The decompiled source
contains the patterns, but recognizing them as "this is the event system" or
"this is how components are composed" requires judgment.

#### 3a. Event System Mapping

**Exploration strategy:**
- Find the base event class/interface (look for a type named `*Event` or
  `Event` that many other `*Event` classes extend).
- Enumerate all concrete event types.
- For each event, identify:
  - What data it carries (fields/getters).
  - Where it is dispatched (search for call sites that instantiate or fire it).
  - Whether it is cancellable.
  - What game action triggers it (inferred from dispatch context).
- Find the event listener registration mechanism (look for `@EventHandler`,
  `registerListener`, or similar patterns).

#### 3b. ECS Component Mapping

**Exploration strategy:**
- Identify the base component type (likely an interface or abstract class).
- Enumerate all concrete components.
- For each component, identify:
  - What data it holds.
  - What systems read or write it (search for typed queries or component access
    patterns).
  - What entity archetypes typically include it (if discoverable from
    registration code or JSON configs).

#### 3c. Command System Mapping

**Exploration strategy:**
- Already partially known from the template (`AbstractCommand`,
  `CommandContext`, `CommandManager`).
- Enumerate all built-in commands (classes extending `AbstractCommand`).
- Document the registration flow, argument parsing, permission model, and
  tab-completion system.

#### 3d. Registry & Asset System Mapping

**Exploration strategy:**
- Find registry classes (types that map string keys to game objects like blocks,
  items, entities).
- Document how plugins register new entries.
- Find the JSON deserialization layer — what classes read the JSON data assets
  and what schema they expect.
- Extract JSON schema definitions (if they exist as code) or infer them from
  the deserialization code.

#### 3e. JSON Data Asset Schema Extraction

**Exploration strategy:**
- Locate the directories/packages that handle asset loading.
- For each asset type (block, item, NPC, world generation config, etc.):
  - Identify the Java class that deserializes it.
  - Extract the expected field names, types, default values, and validation
    constraints.
  - Produce a JSON Schema or equivalent structured representation.
- Cross-reference with any example JSON files bundled in the JAR or referenced
  in the Hytale data directories.

**Outputs:**
- `artifacts/systems.json` — Structured map of each system with its types,
  relationships, and metadata.
- `artifacts/cross-refs.json` — Graph of relationships: "Event X is fired by
  System Y when Component Z changes," etc.

**LLM involvement:** Heavy. The agent needs to read decompiled source, recognize
patterns, make classification judgments, and trace call graphs. This is the
phase most likely to produce errors, so its outputs should be treated as drafts
subject to review.

---

### Phase 4 — Generate Documentation

**Goal:** Produce the final markdown files from the structured artifacts.

**Inputs:** All artifacts from Phases 1–3.

**Outputs:** `output/docs/` — The markdown tree that becomes both the static
site content and the RAG corpus.

**LLM involvement:** Moderate. The LLM generates prose descriptions and usage
notes. The structural content (signatures, type hierarchies, field lists) is
templated from the structured artifacts.

#### Link Resolution Rules

Every markdown link in generated documentation must follow these rules. These
apply to all links in body text, Related Types sections, and tables.

**Rule 1: Every `.md` link must resolve.**
If a generated file contains `[Foo](Foo.md)` or `[Foo](../classes/Foo.md)`,
the target file must exist in the output set. No exceptions.

- If the type has a generated page: link to it with the correct relative path.
- If the type is API surface but has no page yet: do not link to it. Use
  inline code (`` `Foo` ``) as a placeholder. Phase 4.1 will generate the
  missing page and convert the placeholder back to a link.
- If the type is internal (not API surface): always use inline code, never a
  link.

**Rule 2: Relative paths must be correct for the file's location.**
Links are relative to the file that contains them. A file at
`api/commands/index.md` linking to a class page must use `../classes/Foo.md`,
not `Foo.md` (which would resolve to `api/commands/Foo.md`).

Common patterns:
- Same directory: `[Bar](Bar.md)`
- Sibling directory: `[Bar](../classes/Bar.md)`
- Child directory: `[Bar](events/Bar.md)`
- Parent index: `[Overview](../events/index.md)`

**Rule 3: Internal types are never linked.**
Types not in `artifacts/surface.json` (or explicitly marked as internal) must
be referenced as inline code, not links. This includes:
- Implementation classes (`EventBus`, `CommandManager`, `SyncEventBusRegistry`)
- Non-public interfaces (`IEventRegistry`, `IBaseEvent`, `IAsyncEvent`)
- Infrastructure types (`PluginState`, `PluginManifest`, `PacketHandler`)

Exception: If an internal type is the *only* way to accomplish a task that
plugin developers need (e.g., a factory class with no public alternative),
it may be linked and should be flagged for surface reclassification in
`artifacts/surface-review.json`.

**Rule 4: Bidirectional references must both resolve.**
If page A links to page B in its Related Types section, page B should link
back to page A. Both links must resolve. When generating a new page, check
whether existing pages already reference it and ensure the link paths are
consistent in both directions.

**Rule 5: Batch selection must be systematic, not curated.**
Phase 4 must not rely on hand-picked "key types" lists. The file generation
set must be derived from:
1. All types in `artifacts/surface.json` that are referenced by method
   signatures, return types, parameter types, or superclass/interface
   declarations of other generated pages.
2. All overview/index pages for each directory.
3. All event types identified in `artifacts/systems.json`.

Any type that appears in a generated page's method signatures, Related Types
section, or prose cross-references must either have its own page or be
rendered as inline code.

---

### Phase 4.1 — Validate & Gap-Fill

**Goal:** Verify that every `.md` link in the generated documentation resolves
to a file that exists in the output set, and generate any missing pages.

**Inputs:**
- `output/docs/` — The full generated markdown tree from Phase 4.
- `artifacts/surface.json` — API surface classification from Phase 2.
- `artifacts/systems.json` — System mappings from Phase 3.
- `artifacts/decompiled/` — Decompiled source for generating gap-fill pages.

**Outputs:**
- `artifacts/link-audit.json` — Structured report of all link targets, their
  resolution status, and any corrective actions taken.
- Additional files written to `output/docs/` for any gap-filled types.
- Updated `output/docs/progress.json` with gap-fill entries.

**Process:**

1. **Scan.** Walk every `.md` file in `output/docs/`. For each markdown link
   targeting a `.md` file, resolve the relative path to a normalized absolute
   path within the output tree.

2. **Classify.** For each link target that does not have a corresponding file:
   - Look up the type name in `artifacts/surface.json`.
   - If it is an API surface type (public): flag as **must-generate**.
   - If it is an internal type: flag as **must-strip** (convert the link to
     inline code text in the source doc).
   - If it cannot be found in either index: flag as **unknown** for human
     review.

3. **Generate.** For each must-generate type, produce a documentation page
   following the same templates and quality rules as Phase 4. Write it to the
   appropriate location in `output/docs/`.

4. **Fix wrong-path links.** For each link that targets the correct filename
   but in the wrong directory (e.g., `api/commands/AbstractCommand.md` when
   the file exists at `api/classes/AbstractCommand.md`), correct the relative
   path in the source `.md` file.

5. **Strip internal links.** For each must-strip type, replace the markdown
   link with inline code text in the source doc (e.g.,
   `[EventBus](EventBus.md)` → `` `EventBus` ``).

6. **Write audit report.** Produce `artifacts/link-audit.json` recording every
   link target, its resolution, and the action taken.

7. **Assert zero remaining.** After all corrections, re-scan the output tree.
   If any `.md` link still targets a nonexistent file, fail with an error
   listing the remaining violations. Do not proceed to deployment.

**LLM involvement:** Moderate. Generating gap-fill pages requires the same
prose generation as Phase 4. The scan, classify, and fix steps are mechanical.

**Idempotency:** This phase is safe to re-run. It will not duplicate pages that
already exist and will only generate pages for targets that are still missing.

---

## 3. Output Schema — Generated Markdown

### 3.1 Directory Structure

```
output/docs/
├── index.md                          # Landing page / overview
├── meta.json                         # Build metadata (JAR hash, version, timestamp)
│
├── api/                              # Plugin-facing API reference
│   ├── index.md                      # API overview, package listing
│   │
│   ├── classes/                      # One file per class/interface/enum
│   │   ├── JavaPlugin.md
│   │   ├── JavaPluginInit.md
│   │   ├── AbstractCommand.md
│   │   ├── CommandContext.md
│   │   └── ...
│   │
│   ├── events/                       # One file per event
│   │   ├── index.md                  # Event system overview, listener registration
│   │   ├── PlayerJoinEvent.md        # (example name)
│   │   ├── BlockBreakEvent.md        # (example name)
│   │   └── ...
│   │
│   ├── components/                   # One file per ECS component
│   │   ├── index.md                  # ECS overview, component composition patterns
│   │   ├── PositionComponent.md      # (example name)
│   │   ├── HealthComponent.md        # (example name)
│   │   └── ...
│   │
│   ├── systems/                      # One file per ECS system
│   │   ├── index.md                  # Systems overview, execution order
│   │   └── ...
│   │
│   ├── commands/                     # Built-in commands reference
│   │   ├── index.md                  # Command system overview, registration
│   │   └── ...
│   │
│   └── registries/                   # Registry types and registration patterns
│       ├── index.md
│       └── ...
│
├── schemas/                          # JSON data asset schemas
│   ├── index.md                      # Asset system overview
│   ├── block.md                      # Block JSON schema
│   ├── item.md                       # Item JSON schema
│   ├── npc.md                        # NPC JSON schema
│   └── ...
│
└── internals/                        # Internal types (advanced reference)
    ├── index.md                      # Disclaimer: not part of stable API
    └── classes/
        └── ...
```

### 3.2 Frontmatter Schema

Every generated markdown file includes YAML frontmatter. This metadata drives
both the static site (navigation, search, cross-linking) and the RAG (chunk
metadata for retrieval filtering).

```yaml
---
# Required for all files
title: "JavaPlugin"                    # Display title
kind: "class"                          # class | interface | enum | record |
                                       # event | component | system | command |
                                       # registry | schema | overview
package: "com.hypixel.hytale.plugin"   # Java package (omit for schemas)
fqcn: "com.hypixel.hytale.plugin.JavaPlugin"  # Fully qualified class name
api_surface: "public"                  # public | internal
since: "0.5.0"                         # Hytale version first observed (if trackable)
generator_version: "1.0.0"            # Generator version that produced this file
generated_at: "2026-02-09T00:00:00Z"  # Timestamp of generation

# Optional — type-specific
superclass: "java.lang.Object"
interfaces: ["com.hypixel.hytale.plugin.Plugin"]
cancellable: true                     # For events
related:                              # Cross-references
  - kind: "event"
    fqcn: "com.hypixel.hytale.event.PlayerJoinEvent"
    relationship: "fires"
  - kind: "component"
    fqcn: "com.hypixel.hytale.ecs.PositionComponent"
    relationship: "reads"
tags:                                 # Free-form tags for RAG filtering
  - "lifecycle"
  - "plugin-entry-point"
---
```

### 3.3 Class Documentation Template

```markdown
---
(frontmatter as above)
---

# JavaPlugin

> Package: `com.hypixel.hytale.plugin`
> Extends: [`Object`]()
> Implements: [`Plugin`](./Plugin.md)

(1-3 sentence LLM-generated description of what this class is for and when a
plugin developer would use it.)

## Type Hierarchy

- `java.lang.Object`
  - **`com.hypixel.hytale.plugin.JavaPlugin`**
    - (known subclasses in the codebase, if any)

## Constructor

### `JavaPlugin(JavaPluginInit init)`

| Parameter | Type | Description |
|-----------|------|-------------|
| `init` | [`JavaPluginInit`](./JavaPluginInit.md) | (LLM-generated description) |

## Methods

### `onEnable()`

```java
public void onEnable()
```

(LLM-generated description of when this is called and what plugin developers
should do here.)

**Lifecycle position:** Called after the plugin is loaded and dependencies are
resolved. The server is not yet fully started.

---

### `onDisable()`

```java
public void onDisable()
```

(LLM-generated description.)

---

### `getLogger()`

```java
public Logger getLogger()
```

**Returns:** [`Logger`]() — The plugin's named logger instance.

---

## Fields

| Field | Type | Modifiers | Description |
|-------|------|-----------|-------------|
| `logger` | `Logger` | `private final` | (LLM-generated) |

## Related

- **Events:** (list of events this class can listen to or that reference it)
- **Components:** (list of components this class commonly interacts with)
- **See also:** [`JavaPluginInit`](./JavaPluginInit.md), [`Plugin`](./Plugin.md)
```

### 3.4 Event Documentation Template

```markdown
---
(frontmatter with kind: "event", cancellable: true/false)
---

# PlayerJoinEvent

> Package: `com.hypixel.hytale.event.player`
> Extends: [`PlayerEvent`](./PlayerEvent.md)
> Cancellable: Yes / No

(LLM-generated description of when this event fires and what it represents.)

## Fields / Accessors

| Accessor | Return Type | Description |
|----------|-------------|-------------|
| `getPlayer()` | [`Player`](../classes/Player.md) | The player joining. |
| `getJoinMessage()` | `String` | The message broadcast to other players. |
| `setJoinMessage(String)` | `void` | Override the join message. |

## Fired By

(Trace from Phase 3 cross-refs: what code path causes this event to fire.)

- Dispatched by `PlayerConnectionHandler.onLoginComplete()` after
  authentication and world loading are finished.

## Listening

```java
// Example listener registration (pattern discovered from codebase)
@EventHandler
public void onPlayerJoin(PlayerJoinEvent event) {
    getLogger().info(event.getPlayer().getName() + " joined!");
}
```

## Related Events

- [`PlayerDisconnectEvent`](./PlayerDisconnectEvent.md) — Fired when this
  player leaves.
- [`PlayerSpawnEvent`](./PlayerSpawnEvent.md) — Fired after the player entity
  is spawned in the world.
```

### 3.5 Component Documentation Template

```markdown
---
(frontmatter with kind: "component")
---

# PositionComponent

> Package: `com.hypixel.hytale.ecs.component`
> Implements: [`Component`](../classes/Component.md)

(LLM-generated description.)

## Data

| Field | Type | Description |
|-------|------|-------------|
| `x` | `double` | World X coordinate. |
| `y` | `double` | World Y coordinate. |
| `z` | `double` | World Z coordinate. |

## Accessed By Systems

- [`MovementSystem`](../systems/MovementSystem.md) — Reads and writes position
  based on velocity.
- [`CollisionSystem`](../systems/CollisionSystem.md) — Reads position for
  collision detection.

## Common Entity Archetypes

(If discoverable: which entity types typically have this component.)

- All living entities (players, NPCs, mobs)
- Dropped items
- Projectiles
```

### 3.6 JSON Schema Documentation Template

```markdown
---
(frontmatter with kind: "schema")
---

# Block Definition Schema

> Asset path: `Common/Blocks/<block_name>.json`
> Deserialized by: [`BlockDefinitionLoader`](../internals/classes/BlockDefinitionLoader.md)

(LLM-generated overview of what this schema defines.)

## Schema

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `Name` | `string` | yes | — | Internal block identifier. |
| `DisplayName` | `string` | no | `Name` value | Shown in UI. |
| `Hardness` | `float` | no | `1.0` | Mining time multiplier. |
| `BlastResistance` | `float` | no | `1.0` | Explosion resistance. |
| `States` | `object[]` | no | `[]` | Block state definitions. |

## States Object

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `Name` | `string` | yes | — | State identifier. |
| `Values` | `string[]` | yes | — | Possible values. |
| `Default` | `string` | no | first value | Default state value. |

## Example

```json
{
  "Name": "custom_lamp",
  "DisplayName": "Custom Lamp",
  "Hardness": 0.5,
  "States": [
    {
      "Name": "powered",
      "Values": ["on", "off"],
      "Default": "off"
    }
  ]
}
```

## Related

- **Java class:** [`BlockDefinition`](../api/classes/BlockDefinition.md)
- **Registry:** [`BlockRegistry`](../api/registries/BlockRegistry.md)
```

---

## 4. Exploration Heuristics

These are the pattern-matching rules the agent applies during Phase 3. They
should be encoded in the agent instructions (AGENTS.md) so the agent applies
them consistently across runs.

### 4.1 Identifying the Event System

```
LOOK FOR:
- A base class/interface with "Event" in the name that many classes extend.
- A registration mechanism: methods named register*, subscribe*, listen*,
  addListener, on*, or annotations like @EventHandler, @Subscribe.
- A dispatch mechanism: methods named fire*, dispatch*, call*, emit*, post*.
- Cancellation: methods named cancel(), setCancelled(), isCancelled() on
  event classes.

CLASSIFY AS EVENT:
- Any concrete class extending the base event type.
- Exclude abstract intermediate classes (document them as event categories).

TRACE DISPATCH:
- For each event type, find where it is instantiated (new XEvent(...)).
- Follow the instantiation to the fire/dispatch call.
- Note the surrounding method and class as the "fired by" context.
```

### 4.2 Identifying ECS Components

```
LOOK FOR:
- A base type (interface or abstract class) that represents a Component.
  Common names: Component, IComponent, GameComponent, EntityComponent.
- Registration: a method that attaches components to entities, or a builder
  pattern for entity archetypes.
- Access patterns: methods that query entities for specific component types,
  e.g., entity.get(PositionComponent.class).

CLASSIFY AS COMPONENT:
- Any concrete class implementing the base component type.
- Document its data fields (the "columns" of the ECS).

TRACE USAGE:
- Search for typed references to each component class (e.g., in system
  classes, query filters, or archetype builders).
```

### 4.3 Identifying Registries

```
LOOK FOR:
- Classes with names like *Registry, *Manager, *Repository.
- Methods named register(), add(), get(), lookup() that accept string keys
  or ResourceLocation-style identifiers.
- Static instances or singleton patterns (these are typically global).

DOCUMENT:
- What type of game object the registry manages.
- How plugins register new entries.
- How to look up existing entries.
```

### 4.4 Identifying JSON Schemas

```
LOOK FOR:
- Deserialization code: classes that use Gson, Jackson, Codec, or custom
  JSON parsing to read configuration files.
- Field mappings: annotations like @SerializedName, @JsonProperty, or
  explicit field-to-key mappings.
- Default values: assigned in constructors, field initializers, or
  deserialization fallback logic.
- Validation: checks for required fields, value ranges, or enum constraints.

EXTRACT:
- Field name (JSON key)
- Java type → JSON type mapping
- Required vs. optional (inferred from null checks or default assignment)
- Default value
- Validation constraints
```

---

## 5. Agent Instructions (AGENTS.md)

This file goes in the root of the generator project and instructs the LLM agent
on how to operate the pipeline.

```markdown
# Hytale Server API Index — Agent Instructions

## Project Overview

This project generates documentation from the Hytale server JAR. The output
is structured markdown that feeds a static documentation site and a RAG
corpus. All documentation is mechanically derived from the game files — never
from external sources.

## Pipeline

Run phases in order. Each phase reads from `artifacts/` and writes to
`artifacts/` or `output/`. Do not skip phases.

### Phase 1: Decompile & Index

1. Decompile `input/HytaleServer.jar` using Vineflower.
   Output to `artifacts/decompiled/`.
2. Parse the decompiled source with JavaParser and produce
   `artifacts/class-index.json` per the schema in the spec.
3. This phase is deterministic. Do not use LLM judgment. If the decompiler
   or parser fails on a file, log the error and continue.

### Phase 2: Classify API Surface

1. Load `artifacts/class-index.json`.
2. Start from the seed types listed in the spec (Section 2, Phase 2).
3. Expand transitively per the expansion rules.
4. Write `artifacts/surface.json` and `artifacts/internal-index.json`.
5. Flag borderline cases in `artifacts/surface-review.json` for human
   review. Do not silently reclassify.

### Phase 3: Map Systems & Cross-Reference

1. Load the decompiled source and the API surface classification.
2. Apply the exploration heuristics from Section 4 of the spec.
3. For each system (events, ECS, commands, registries, JSON schemas):
   - Identify all relevant types.
   - Trace relationships (dispatch sites, access patterns, etc.).
   - Record findings in `artifacts/systems.json` and
     `artifacts/cross-refs.json`.
4. When uncertain about a classification, record your confidence level
   and reasoning. Prefer false positives (documenting too much) over
   false negatives (missing something).

### Phase 4: Generate Docs

1. Load all artifacts.
2. For each type in the API surface, generate a markdown file following
   the templates in Section 3 of the spec.
3. For structural content (signatures, fields, hierarchies): template
   directly from the structured artifacts. Do not rephrase or reformat
   method signatures.
4. For prose content (descriptions, usage notes, "fired by" context):
   generate concise, accurate descriptions based on the decompiled source.
   State what the code does, not what you think it might do. If you
   cannot determine purpose from the code, say so explicitly.
5. Generate index files for each directory.
6. Write output to `output/docs/`.

## Quality Rules

- Never invent API that doesn't exist in the source.
- Never omit public API that does exist in the source.
- Method signatures must be character-perfect copies from the decompiled
  source.
- Cross-references must be bidirectional: if A references B, B must
  reference A.
- Every generated file must have complete frontmatter per the spec.
- When you don't know something, say "Purpose unknown — inferred from
  usage context" rather than guessing.
- Every .md link must resolve to a file in the output set. If a target
  file does not exist, use inline code (`TypeName`) instead of a link.
  Phase 4.1 will gap-fill missing API surface pages.
- Links must use correct relative paths for the file's directory location.
  A file in api/commands/ linking to api/classes/Foo.md must use
  ../classes/Foo.md, not Foo.md.
- Internal types (not in surface.json) are never linked — always use
  inline code.
- After Phase 4 generation, run Phase 4.1 to validate all links resolve.
  The pipeline must not deploy with any dangling .md links.

## File Locations

- `input/` — Place the HytaleServer.jar here.
- `artifacts/` — Intermediate pipeline outputs. Committed to git for
  debuggability.
- `output/docs/` — Final generated documentation. This becomes the
  static site content and RAG source.
- `spec/` — This spec and related design documents.
```

---

## 6. Tooling Requirements

| Tool | Purpose | Phase |
|------|---------|-------|
| **Vineflower** | Java decompiler (modern Fernflower fork) | 1 |
| **JavaParser** | Parse decompiled Java source into AST | 1 |
| **Java 25 JDK** | Required to run Hytale-compatible tooling | 1 |
| **LLM Agent** | AI coding agent for classification and generation | 2, 3, 4 |
| **Git** | Version control for artifacts and output | All |

### Build tooling

The Phase 1-2 tooling is a Java CLI in `tools/` (Gradle project using
Vineflower 1.11.2 and JavaParser 3.28.0). Entry points:
- `tools/run.sh <jar>` — Decompile and produce `class-index.json`
- `tools/classify.sh` — Classify API surface from the class index

The CLI takes a JAR path as input and produces the `artifacts/` outputs. It
can be invoked by the LLM agent via shell but does not itself require LLM
involvement.

---

## 7. Versioning Strategy

The documentation version tracks the Hytale build, not its own release cycle.

```
docs version = <hytale_version>-gen.<generator_version>
example:      0.5.1-gen.1.0.0
```

- When a new Hytale JAR is processed, the Hytale version increments.
- When the generator is improved without a new JAR, the generator version
  increments and the docs are regenerated from the same JAR.
- The `meta.json` in the output root records both versions plus the JAR hash.

---

## 8. Open Questions

These are known unknowns to resolve during implementation.

1. **Decompiler fidelity on Java 25.** Vineflower is the best available, but
   Java 25 features may cause decompilation artifacts. Need to test against
   the actual JAR and document any classes that decompile poorly.

2. **ECS framework identity.** The Hytale team referenced "Flecs" (a C/C++
   ECS), but the Java server likely uses a custom implementation or a Java
   port. The exploration heuristics may need adjustment once the actual
   component/system patterns are visible.

3. **JSON schema complexity.** If Hytale uses Mojang-style Codecs (from
   DataFixerUpper) or a similar declarative serialization system, schema
   extraction becomes significantly easier (parse the Codec definitions)
   or harder (if the Codec DSL is complex). Need to identify the
   serialization approach early.

4. **Scope of "asset packs" vs. "plugins."** The modding strategy post
   distinguishes between data-driven asset packs and Java plugins. This
   generator focuses on the Java API and JSON schemas. Pure visual assets
   (models, textures, animations) are out of scope unless they have a
   programmatic interface.

5. **Rate of API churn.** In early access, the API surface may change
   significantly between updates. The versioning strategy handles this, but
   the generator may need a "diff" mode that highlights what changed between
   versions for the documentation site.

---

## 9. Build-Time Link Assertion

The sync script (`site/scripts/sync-docs.mjs`) supports a `--strict` flag
that causes the build to fail if any dangling links are detected.

**Behavior:**
- Without `--strict`: Dangling links are stripped to inline code and logged as
  warnings. The build succeeds. This is the development/iteration mode.
- With `--strict`: Dangling links are logged as errors and the process exits
  with code 1. The build fails. This is the CI/deployment mode.

**CI integration:** The Cloudflare Pages build command should use:
```
npm run build -- --strict
```

This ensures that no deployment can go live with broken internal references.
The sync script passes unrecognized arguments through, so the `--strict` flag
is consumed by the sync step before Astro builds.

**Dangling link report format:**
```
=== DANGLING LINKS: N missing targets ===
  MISSING: api/classes/EventRegistration.md (4 links)
    ← api/classes/EventRegistry.md  [EventRegistration]
    ← api/classes/PluginBase.md     [EventRegistration]
    ...
=== END DANGLING LINKS ===
ERROR: --strict mode: 13 dangling links found across 8 missing targets. Build aborted.
```

---

## Appendix: Link Audit JSON Schema

`artifacts/link-audit.json` records the results of Phase 4.1 validation.

```json
{
  "generated_at": "2026-02-10T06:00:00Z",
  "total_links_scanned": 377,
  "total_files_scanned": 65,
  "dangling_targets": [
    {
      "target": "api/classes/EventRegistration.md",
      "surface_classification": "public",
      "action": "generated",
      "referenced_by": [
        { "source": "api/classes/EventRegistry.md", "text": "EventRegistration", "count": 2 },
        { "source": "api/classes/PluginBase.md", "text": "EventRegistration", "count": 1 },
        { "source": "api/events/index.md", "text": "EventRegistration", "count": 1 }
      ]
    },
    {
      "target": "api/commands/AbstractCommand.md",
      "surface_classification": "n/a",
      "action": "path_corrected",
      "corrected_to": "../classes/AbstractCommand.md",
      "referenced_by": [
        { "source": "api/commands/index.md", "text": "AbstractCommand", "count": 2 }
      ]
    }
  ],
  "wrong_path_links": 6,
  "missing_pages_generated": 4,
  "internal_links_stripped": 0,
  "remaining_violations": 0
}
```
